<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H1B Data Viewer - Interactive H1B Visa Application Explorer</title>
    <meta name="description"
        content="Interactive viewer for H1B visa application data with filtering, sorting, and detailed analysis capabilities">

    <style>
        /* CSS Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: #374151;
            background-color: #f9fafb;
        }

        /* Layout Structure */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .header {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            gap: 2rem;
        }

        /* Summary Statistics Cards */
        .stats-section {
            margin-bottom: 2rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
        }

        .stat-card h3 {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .stat-card .value {
            font-size: 2rem;
            font-weight: 700;
            color: #1f2937;
        }

        /* Controls Section */
        .controls-section {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            margin-bottom: 2rem;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            align-items: end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #374151;
        }

        .control-group input,
        .control-group select {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 0.875rem;
            background: white;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .search-input {
            grid-column: 1 / -1;
        }

        .search-input input {
            width: 100%;
            padding: 1rem;
            font-size: 1rem;
            border: 2px solid #d1d5db;
            border-radius: 8px;
        }

        .clear-filters-btn {
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .clear-filters-btn:hover {
            background: #4b5563;
        }

        /* Table Section */
        .table-section {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }

        .table-container {
            overflow-x: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th {
            background: #f9fafb;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
        }

        .data-table th:hover {
            background: #f3f4f6;
        }

        .data-table th.sortable::after {
            content: 'â†•';
            position: absolute;
            right: 0.5rem;
            opacity: 0.4;
            font-size: 0.875rem;
            transition: opacity 0.2s;
        }

        .data-table th.sortable:hover::after {
            opacity: 0.7;
        }

        .data-table th.sort-asc::after {
            content: 'â†‘';
            opacity: 1;
            color: #2563eb;
            font-weight: bold;
        }

        .data-table th.sort-desc::after {
            content: 'â†“';
            opacity: 1;
            color: #2563eb;
            font-weight: bold;
        }

        .data-table th.sortable.sort-asc,
        .data-table th.sortable.sort-desc {
            background: #f0f7ff;
            color: #1e40af;
        }

        .data-table th.sortable.sort-asc:hover,
        .data-table th.sortable.sort-desc:hover {
            background: #e0f2fe;
        }

        .data-table td {
            padding: 1rem;
            border-bottom: 1px solid #f3f4f6;
        }

        .data-table tbody tr {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .data-table tbody tr:hover {
            background: #f9fafb;
        }

        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-certified {
            background: #dcfce7;
            color: #16a34a;
        }

        .status-withdrawn {
            background: #fef3c7;
            color: #d97706;
        }

        .status-denied {
            background: #fee2e2;
            color: #dc2626;
        }

        /* Pagination */
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            padding: 1.5rem;
            border-top: 1px solid #e5e7eb;
            flex-wrap: wrap;
        }

        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            width: 100%;
            justify-content: space-between;
        }

        .pagination-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .pagination-btn {
            padding: 0.5rem 0.75rem;
            border: 1px solid #d1d5db;
            background: white;
            color: #374151;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            min-width: 2.5rem;
            text-align: center;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f9fafb;
        }

        .pagination-btn.active {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        .pagination-btn.active:hover {
            background: #1d4ed8;
            border-color: #1d4ed8;
        }

        .pagination-ellipsis {
            padding: 0.5rem 0.25rem;
            color: #6b7280;
            font-weight: 500;
        }

        .pagination-info {
            color: #6b7280;
            font-size: 0.875rem;
            white-space: nowrap;
        }

        .page-size-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #6b7280;
        }

        .page-size-select {
            padding: 0.25rem 0.5rem;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            font-size: 0.875rem;
        }

        .page-size-select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            max-width: 800px;
            max-height: 90vh;
            width: 90%;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            padding: 0.5rem;
            margin-left: auto;
        }

        .modal-close:hover {
            color: #374151;
        }

        .modal-body {
            padding: 1.5rem;
        }

        /* Loading State */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 4rem;
            color: #6b7280;
        }

        .spinner {
            width: 2rem;
            height: 2rem;
            border: 2px solid #e5e7eb;
            border-top: 2px solid #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 1rem;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Error State */
        .error {
            background: #fee2e2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            text-align: center;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: #6b7280;
        }

        .empty-state h3 {
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        /* Data Source Status */
        .data-source-indicator {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.875rem;
        }

        .data-source-indicator.supabase {
            border-left: 4px solid #10b981;
        }

        .data-source-indicator.local {
            border-left: 4px solid #f59e0b;
        }

        .data-source-indicator.error {
            border-left: 4px solid #ef4444;
        }

        .data-source-icon {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 0.75rem;
        }

        .data-source-icon.supabase {
            background: #10b981;
        }

        .data-source-icon.local {
            background: #f59e0b;
        }

        .data-source-icon.error {
            background: #ef4444;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .data-table {
                font-size: 0.875rem;
            }

            .data-table th,
            .data-table td {
                padding: 0.75rem 0.5rem;
            }

            .modal-content {
                width: 95%;
                margin: 1rem;
            }
        }

        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }

            .pagination {
                padding: 1rem;
            }

            .pagination-controls {
                flex-direction: column;
                gap: 0.75rem;
                align-items: center;
            }

            .pagination-nav {
                gap: 0.25rem;
                flex-wrap: wrap;
                justify-content: center;
            }

            .pagination-btn {
                padding: 0.5rem;
                min-width: 2.5rem;
                font-size: 0.875rem;
            }

            .pagination-info {
                order: -1;
                text-align: center;
            }

            .page-size-selector {
                order: 1;
                justify-content: center;
            }
        }
    </style>
</head>

<body>
    <!-- Header Section -->
    <header class="header">
        <div class="container">
            <h1>H1B Data Viewer</h1>
            <p>Interactive explorer for H1B visa application data with advanced filtering and analysis</p>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container">
        <!-- Data Source Status -->
        <section class="data-source-status" id="dataSourceStatus" style="margin-bottom: 1rem;">
            <!-- Data source indicator will be populated by JavaScript -->
        </section>

        <!-- Summary Statistics Section -->
        <section class="stats-section">
            <div class="stats-grid" id="statsGrid">
                <!-- Statistics cards will be populated by JavaScript -->
            </div>
        </section>

        <!-- Controls Section -->
        <section class="controls-section">
            <div class="controls-grid">
                <div class="control-group search-input">
                    <label for="searchInput">Search Applications</label>
                    <input type="text" id="searchInput" placeholder="Search by employer, job title, or case number...">
                </div>

                <div class="control-group">
                    <label for="employerFilter">Employer</label>
                    <select id="employerFilter">
                        <option value="">All Employers</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="statusFilter">Case Status</label>
                    <select id="statusFilter">
                        <option value="">All Statuses</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="jobTitleFilter">Job Title</label>
                    <select id="jobTitleFilter">
                        <option value="">All Job Titles</option>
                    </select>
                </div>

                <div class="control-group">
                    <label for="minSalary">Min Salary</label>
                    <input type="number" id="minSalary" placeholder="0" min="0">
                </div>

                <div class="control-group">
                    <label for="maxSalary">Max Salary</label>
                    <input type="number" id="maxSalary" placeholder="No limit" min="0">
                </div>

                <div class="control-group">
                    <button type="button" class="clear-filters-btn" id="clearFilters">Clear Filters</button>
                </div>

                <div class="control-group">
                    <button type="button" class="clear-filters-btn" id="runTests" onclick="runDataProcessingTests()"
                        style="background: #059669;">Run Tests</button>
                </div>
            </div>
        </section>

        <!-- Table Section -->
        <section class="table-section">
            <div class="table-container">
                <table class="data-table" id="dataTable">
                    <thead>
                        <tr>
                            <th class="sortable" data-column="CASE_NUMBER">Case Number</th>
                            <th class="sortable" data-column="EMPLOYER_NAME">Employer</th>
                            <th class="sortable" data-column="JOB_TITLE">Job Title</th>
                            <th class="sortable" data-column="CASE_STATUS">Status</th>
                            <th class="sortable" data-column="WAGE_RATE_OF_PAY_FROM">Salary</th>
                            <th class="sortable" data-column="WORKSITE_CITY">Location</th>
                            <th class="sortable" data-column="DECISION_DATE">Decision Date</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <!-- Table rows will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>

            <!-- Pagination -->
            <div class="pagination" id="pagination">
                <!-- Pagination controls will be populated by JavaScript -->
            </div>
        </section>
    </main>

    <!-- Modal for Detailed View -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Application Details</h2>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
                <!-- Modal content will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        /**
         * Supabase Configuration
         * Configure your Supabase connection here
         */
        const SUPABASE_CONFIG = {
            url: 'https://gbsodywfisfmfkwspnaf.supabase.co',
            anonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imdic29keXdmaXNmbWZrd3NwbmFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzc2NzA4NDEsImV4cCI6MjA1MzI0Njg0MX0.pXeMCsqx2OWIKoVGp549GPIn6HEu6jA8Ca25EHIpmd8',
            tableName: 'h1b_applications'
        };

        // Initialize Supabase client - REQUIRED for this application
        let supabaseClient = null;
        try {
            if (!SUPABASE_CONFIG.url || !SUPABASE_CONFIG.anonKey ||
                SUPABASE_CONFIG.url === 'YOUR_SUPABASE_URL' ||
                SUPABASE_CONFIG.anonKey === 'YOUR_SUPABASE_ANON_KEY') {

                throw new Error('Supabase configuration is missing or incomplete. Please configure your Supabase credentials.');
            }

            supabaseClient = supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
            console.log('âœ… Supabase client initialized successfully');
            console.log(`ðŸ”— Connected to: ${SUPABASE_CONFIG.url}`);
            console.log(`ðŸ“‹ Table: ${SUPABASE_CONFIG.tableName}`);

            // Test connection
            supabaseClient.from(SUPABASE_CONFIG.tableName).select('id').limit(1).then(result => {
                if (result.error) {
                    console.warn('âš ï¸ Supabase connection test failed:', result.error.message);
                } else {
                    console.log('âœ… Supabase connection test successful');
                }
            }).catch(error => {
                console.warn('âš ï¸ Supabase connection test error:', error.message);
            });

        } catch (error) {
            console.error('âŒ Error initializing Supabase client:', error);
            console.error('âŒ This application requires Supabase to be configured properly.');
            console.error('Please check your SUPABASE_CONFIG settings.');

            // Show error in UI immediately
            document.addEventListener('DOMContentLoaded', () => {
                updateDataSourceStatus('error', 'Supabase configuration missing or invalid', true);
            });
        }

        /**
         * DataManager class for handling H1B data operations
         * Handles data parsing, validation, filtering, sorting, and statistics
         */
        class DataManager {
            constructor(rawData = []) {
                this.rawData = rawData;
                this.processedData = [];
                this.filteredData = [];
                this.currentFilters = {
                    employer: '',
                    status: '',
                    jobTitle: '',
                    minSalary: null,
                    maxSalary: null,
                    searchTerm: ''
                };
                this.currentSort = {
                    column: null,
                    direction: 'asc'
                };

                if (rawData.length > 0) {
                    this.processData();
                }
            }

            /**
             * Process and validate raw H1B data
             * Normalizes dates, salaries, and other fields
             */
            processData() {
                this.processedData = this.rawData.map(record => {
                    const processed = { ...record };

                    // Parse and normalize dates
                    processed.RECEIVED_DATE_PARSED = this.parseDate(record.RECEIVED_DATE);
                    processed.DECISION_DATE_PARSED = this.parseDate(record.DECISION_DATE);
                    processed.BEGIN_DATE_PARSED = this.parseDate(record.BEGIN_DATE);
                    processed.END_DATE_PARSED = this.parseDate(record.END_DATE);

                    // Normalize salary to annual amount
                    processed.ANNUAL_SALARY = this.normalizeSalary(
                        record.WAGE_RATE_OF_PAY_FROM,
                        record.WAGE_UNIT_OF_PAY
                    );

                    // Create formatted location string
                    processed.LOCATION = this.formatLocation(record.WORKSITE_CITY, record.WORKSITE_STATE);

                    // Normalize case status for consistent filtering
                    processed.CASE_STATUS_NORMALIZED = this.normalizeStatus(record.CASE_STATUS);

                    // Create searchable text for global search
                    processed.SEARCHABLE_TEXT = this.createSearchableText(processed);

                    return processed;
                });

                // Initialize filtered data with all processed data
                this.filteredData = [...this.processedData];

                console.log(`Processed ${this.processedData.length} H1B records`);
            }

            /**
             * Parse date strings into Date objects
             * Handles various date formats commonly found in H1B data
             */
            parseDate(dateString) {
                if (!dateString || dateString === '' || dateString === 'N/A') {
                    return null;
                }

                try {
                    // Handle common date formats: YYYY-MM-DD, MM/DD/YYYY, etc.
                    const date = new Date(dateString);

                    // Check if date is valid
                    if (isNaN(date.getTime())) {
                        return null;
                    }

                    return date;
                } catch (error) {
                    console.warn(`Failed to parse date: ${dateString}`, error);
                    return null;
                }
            }

            /**
             * Normalize salary amounts to annual values
             * Converts hourly, monthly, etc. to yearly amounts
             */
            normalizeSalary(wageAmount, wageUnit) {
                if (!wageAmount || isNaN(parseFloat(wageAmount))) {
                    return 0;
                }

                const amount = parseFloat(wageAmount);
                const unit = (wageUnit || '').toLowerCase().trim();

                // Conversion factors to annual salary
                const conversionFactors = {
                    'year': 1,
                    'yearly': 1,
                    'annual': 1,
                    'month': 12,
                    'monthly': 12,
                    'week': 52,
                    'weekly': 52,
                    'hour': 2080, // 40 hours/week * 52 weeks
                    'hourly': 2080,
                    'bi-weekly': 26,
                    'biweekly': 26
                };

                // Find matching conversion factor
                for (const [key, factor] of Object.entries(conversionFactors)) {
                    if (unit.includes(key)) {
                        return Math.round(amount * factor);
                    }
                }

                // Default to treating as annual if unit is unclear
                return Math.round(amount);
            }

            /**
             * Format location string from city and state
             */
            formatLocation(city, state) {
                const cityStr = (city || '').trim();
                const stateStr = (state || '').trim();

                if (cityStr && stateStr) {
                    return `${cityStr}, ${stateStr}`;
                } else if (cityStr) {
                    return cityStr;
                } else if (stateStr) {
                    return stateStr;
                } else {
                    return 'N/A';
                }
            }

            /**
             * Normalize case status for consistent filtering
             */
            normalizeStatus(status) {
                if (!status) return 'Unknown';

                const statusLower = status.toLowerCase().trim();

                if (statusLower.includes('certified')) {
                    return 'Certified';
                } else if (statusLower.includes('denied')) {
                    return 'Denied';
                } else if (statusLower.includes('withdrawn')) {
                    return 'Withdrawn';
                } else {
                    return status.trim();
                }
            }

            /**
             * Create searchable text for global search functionality
             */
            createSearchableText(record) {
                const searchFields = [
                    record.CASE_NUMBER,
                    record.EMPLOYER_NAME,
                    record.JOB_TITLE,
                    record.SOC_TITLE,
                    record.WORKSITE_CITY,
                    record.WORKSITE_STATE,
                    record.EMPLOYER_CITY,
                    record.EMPLOYER_STATE
                ];

                return searchFields
                    .filter(field => field && field !== '')
                    .join(' ')
                    .toLowerCase();
            }

            /**
             * Validate a single H1B record
             * Returns validation errors if any
             */
            validateRecord(record) {
                const errors = [];

                if (!record.CASE_NUMBER) {
                    errors.push('Missing case number');
                }

                if (!record.EMPLOYER_NAME) {
                    errors.push('Missing employer name');
                }

                if (!record.JOB_TITLE) {
                    errors.push('Missing job title');
                }

                if (!record.CASE_STATUS) {
                    errors.push('Missing case status');
                }

                return errors;
            }

            /**
             * Get unique values for a specific field (used for filter dropdowns)
             */
            getUniqueValues(fieldName, limit = null) {
                const values = new Set();

                this.processedData.forEach(record => {
                    const value = record[fieldName];
                    if (value && value !== '' && value !== 'N/A') {
                        values.add(value);
                    }
                });

                const sortedValues = Array.from(values).sort();

                return limit ? sortedValues.slice(0, limit) : sortedValues;
            }

            /**
             * Get data for the current page with pagination
             */
            getPaginatedData(page = 1, pageSize = 50) {
                const startIndex = (page - 1) * pageSize;
                const endIndex = startIndex + pageSize;

                return {
                    data: this.filteredData.slice(startIndex, endIndex),
                    totalRecords: this.filteredData.length,
                    totalPages: Math.ceil(this.filteredData.length / pageSize),
                    currentPage: page,
                    pageSize: pageSize,
                    hasNextPage: endIndex < this.filteredData.length,
                    hasPreviousPage: page > 1
                };
            }

            /**
             * Get summary statistics for current filtered data
             */
            getStatistics() {
                if (this.filteredData.length === 0) {
                    return {
                        totalApplications: 0,
                        averageSalary: 0,
                        medianSalary: 0,
                        minSalary: 0,
                        maxSalary: 0,
                        topEmployers: [],
                        statusBreakdown: {},
                        certificationRate: 0
                    };
                }

                // Calculate salary statistics
                const salaries = this.filteredData
                    .map(record => record.ANNUAL_SALARY)
                    .filter(salary => salary > 0)
                    .sort((a, b) => a - b);

                const averageSalary = salaries.length > 0
                    ? Math.round(salaries.reduce((sum, salary) => sum + salary, 0) / salaries.length)
                    : 0;

                const medianSalary = salaries.length > 0
                    ? salaries[Math.floor(salaries.length / 2)]
                    : 0;

                // Calculate top employers
                const employerCounts = {};
                this.filteredData.forEach(record => {
                    const employer = record.EMPLOYER_NAME;
                    if (employer) {
                        employerCounts[employer] = (employerCounts[employer] || 0) + 1;
                    }
                });

                const topEmployers = Object.entries(employerCounts)
                    .sort(([, a], [, b]) => b - a)
                    .slice(0, 5)
                    .map(([name, count]) => ({ name, count }));

                // Calculate status breakdown
                const statusBreakdown = {};
                this.filteredData.forEach(record => {
                    const status = record.CASE_STATUS_NORMALIZED;
                    statusBreakdown[status] = (statusBreakdown[status] || 0) + 1;
                });

                // Calculate certification rate
                const certifiedCount = statusBreakdown['Certified'] || 0;
                const certificationRate = this.filteredData.length > 0
                    ? Math.round((certifiedCount / this.filteredData.length) * 100)
                    : 0;

                return {
                    totalApplications: this.filteredData.length,
                    averageSalary,
                    medianSalary,
                    minSalary: salaries.length > 0 ? salaries[0] : 0,
                    maxSalary: salaries.length > 0 ? salaries[salaries.length - 1] : 0,
                    topEmployers,
                    statusBreakdown,
                    certificationRate
                };
            }

            /**
             * Sort data by column and direction
             * Handles different data types: string, numeric, date
             */
            sortData(column, direction = 'asc') {
                if (!column) {
                    console.warn('No column specified for sorting');
                    return this.filteredData;
                }

                // Create a copy to avoid mutating the original array
                const sortedData = [...this.filteredData];

                sortedData.sort((a, b) => {
                    let valueA = this.getSortValue(a, column);
                    let valueB = this.getSortValue(b, column);

                    // Handle null/undefined values - always sort them to the end
                    if (valueA == null && valueB == null) return 0;
                    if (valueA == null) return 1;
                    if (valueB == null) return -1;

                    let comparison = 0;

                    // Determine sort type based on column
                    const sortType = this.getSortType(column);

                    switch (sortType) {
                        case 'numeric':
                            comparison = this.compareNumeric(valueA, valueB);
                            break;
                        case 'date':
                            comparison = this.compareDate(valueA, valueB);
                            break;
                        case 'string':
                        default:
                            comparison = this.compareString(valueA, valueB);
                            break;
                    }

                    // Apply sort direction
                    return direction === 'desc' ? -comparison : comparison;
                });

                // Update current sort state
                this.currentSort.column = column;
                this.currentSort.direction = direction;

                // Update filtered data with sorted results
                this.filteredData = sortedData;

                console.log(`Sorted ${sortedData.length} records by ${column} (${direction})`);
                return sortedData;
            }

            /**
             * Get the appropriate value for sorting from a record
             */
            getSortValue(record, column) {
                switch (column) {
                    case 'CASE_NUMBER':
                        return record.CASE_NUMBER;
                    case 'EMPLOYER_NAME':
                        return record.EMPLOYER_NAME;
                    case 'JOB_TITLE':
                        return record.JOB_TITLE;
                    case 'CASE_STATUS':
                        return record.CASE_STATUS_NORMALIZED || record.CASE_STATUS;
                    case 'WAGE_RATE_OF_PAY_FROM':
                        return record.ANNUAL_SALARY || parseFloat(record.WAGE_RATE_OF_PAY_FROM) || 0;
                    case 'WORKSITE_CITY':
                    case 'LOCATION':
                        return record.LOCATION || this.formatLocation(record.WORKSITE_CITY, record.WORKSITE_STATE);
                    case 'DECISION_DATE':
                        return record.DECISION_DATE_PARSED || this.parseDate(record.DECISION_DATE);
                    case 'RECEIVED_DATE':
                        return record.RECEIVED_DATE_PARSED || this.parseDate(record.RECEIVED_DATE);
                    case 'BEGIN_DATE':
                        return record.BEGIN_DATE_PARSED || this.parseDate(record.BEGIN_DATE);
                    case 'END_DATE':
                        return record.END_DATE_PARSED || this.parseDate(record.END_DATE);
                    default:
                        return record[column];
                }
            }

            /**
             * Determine the sort type for a column
             */
            getSortType(column) {
                const numericColumns = [
                    'WAGE_RATE_OF_PAY_FROM',
                    'ANNUAL_SALARY',
                    'PREVAILING_WAGE'
                ];

                const dateColumns = [
                    'DECISION_DATE',
                    'RECEIVED_DATE',
                    'BEGIN_DATE',
                    'END_DATE'
                ];

                if (numericColumns.includes(column)) {
                    return 'numeric';
                } else if (dateColumns.includes(column)) {
                    return 'date';
                } else {
                    return 'string';
                }
            }

            /**
             * Compare two string values for sorting
             */
            compareString(a, b) {
                const strA = String(a || '').toLowerCase().trim();
                const strB = String(b || '').toLowerCase().trim();

                return strA.localeCompare(strB, 'en', {
                    numeric: true,
                    sensitivity: 'base'
                });
            }

            /**
             * Compare two numeric values for sorting
             */
            compareNumeric(a, b) {
                const numA = parseFloat(a) || 0;
                const numB = parseFloat(b) || 0;

                return numA - numB;
            }

            /**
             * Compare two date values for sorting
             */
            compareDate(a, b) {
                const dateA = a instanceof Date ? a : this.parseDate(a);
                const dateB = b instanceof Date ? b : this.parseDate(b);

                // Handle invalid dates
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;

                return dateA.getTime() - dateB.getTime();
            }

            /**
             * Apply filters to the processed data
             * Combines multiple filter criteria using AND logic
             */
            applyFilters(filters = {}) {
                // Update current filters
                this.currentFilters = { ...this.currentFilters, ...filters };

                // Start with all processed data
                let filtered = [...this.processedData];

                // Apply employer filter
                if (this.currentFilters.employer && this.currentFilters.employer !== '') {
                    filtered = filtered.filter(record =>
                        record.EMPLOYER_NAME &&
                        record.EMPLOYER_NAME.toLowerCase().includes(this.currentFilters.employer.toLowerCase())
                    );
                }

                // Apply status filter
                if (this.currentFilters.status && this.currentFilters.status !== '') {
                    filtered = filtered.filter(record =>
                        record.CASE_STATUS_NORMALIZED === this.currentFilters.status ||
                        record.CASE_STATUS === this.currentFilters.status
                    );
                }

                // Apply job title filter
                if (this.currentFilters.jobTitle && this.currentFilters.jobTitle !== '') {
                    filtered = filtered.filter(record =>
                        record.JOB_TITLE &&
                        record.JOB_TITLE.toLowerCase().includes(this.currentFilters.jobTitle.toLowerCase())
                    );
                }

                // Apply salary range filters
                if (this.currentFilters.minSalary !== null && this.currentFilters.minSalary !== undefined) {
                    const minSalary = parseFloat(this.currentFilters.minSalary);
                    if (!isNaN(minSalary)) {
                        filtered = filtered.filter(record =>
                            record.ANNUAL_SALARY >= minSalary
                        );
                    }
                }

                if (this.currentFilters.maxSalary !== null && this.currentFilters.maxSalary !== undefined) {
                    const maxSalary = parseFloat(this.currentFilters.maxSalary);
                    if (!isNaN(maxSalary)) {
                        filtered = filtered.filter(record =>
                            record.ANNUAL_SALARY <= maxSalary
                        );
                    }
                }

                // Apply global search filter
                if (this.currentFilters.searchTerm && this.currentFilters.searchTerm.trim() !== '') {
                    const searchTerm = this.currentFilters.searchTerm.toLowerCase().trim();
                    filtered = filtered.filter(record =>
                        record.SEARCHABLE_TEXT.includes(searchTerm)
                    );
                }

                // Update filtered data
                this.filteredData = filtered;

                // Re-apply current sort if one is active
                if (this.currentSort.column) {
                    this.sortData(this.currentSort.column, this.currentSort.direction);
                }

                console.log(`Applied filters: ${this.processedData.length} â†’ ${this.filteredData.length} records`);

                return this.filteredData;
            }

            /**
             * Clear all filters and reset to show all data
             */
            clearFilters() {
                this.currentFilters = {
                    employer: '',
                    status: '',
                    jobTitle: '',
                    minSalary: null,
                    maxSalary: null,
                    searchTerm: ''
                };

                this.filteredData = [...this.processedData];

                // Re-apply current sort if one is active
                if (this.currentSort.column) {
                    this.sortData(this.currentSort.column, this.currentSort.direction);
                }

                console.log('Filters cleared, showing all records');
                return this.filteredData;
            }

            /**
             * Search data across multiple fields
             * Used for global search functionality
             */
            searchData(searchTerm) {
                if (!searchTerm || searchTerm.trim() === '') {
                    return this.applyFilters({ searchTerm: '' });
                }

                return this.applyFilters({ searchTerm: searchTerm.trim() });
            }

            /**
             * Get current filter state
             */
            getCurrentFilters() {
                return { ...this.currentFilters };
            }

            /**
             * Get current sort state
             */
            getCurrentSort() {
                return { ...this.currentSort };
            }
        }

        /**
         * FilterManager class for handling filter operations
         * Manages filter state, UI controls, and filter application logic
         */
        class FilterManager {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.filterState = {
                    employer: '',
                    status: '',
                    jobTitle: '',
                    minSalary: null,
                    maxSalary: null,
                    searchTerm: ''
                };
                this.filterElements = {};
                this.initialized = false;
            }

            /**
             * Initialize filter controls and populate dropdowns
             */
            initializeFilters(data) {
                if (!data || data.length === 0) {
                    console.warn('No data provided for filter initialization');
                    return;
                }

                // Get DOM elements
                this.filterElements = {
                    employer: document.getElementById('employerFilter'),
                    status: document.getElementById('statusFilter'),
                    jobTitle: document.getElementById('jobTitleFilter'),
                    minSalary: document.getElementById('minSalary'),
                    maxSalary: document.getElementById('maxSalary'),
                    searchInput: document.getElementById('searchInput'),
                    clearButton: document.getElementById('clearFilters')
                };

                // Populate dropdown filters
                this.populateEmployerFilter(data);
                this.populateStatusFilter(data);
                this.populateJobTitleFilter(data);

                // Set up event listeners
                this.setupEventListeners();

                this.initialized = true;
                console.log('FilterManager initialized with filter controls');
            }

            /**
             * Extract unique values for dropdown filters
             */
            getUniqueValues(data, fieldName, limit = null) {
                const values = new Set();

                data.forEach(record => {
                    const value = record[fieldName];
                    if (value && value !== '' && value !== 'N/A' && value.trim() !== '') {
                        values.add(value.trim());
                    }
                });

                const sortedValues = Array.from(values).sort((a, b) =>
                    a.toLowerCase().localeCompare(b.toLowerCase())
                );

                return limit ? sortedValues.slice(0, limit) : sortedValues;
            }

            /**
             * Populate employer dropdown filter
             */
            populateEmployerFilter(data) {
                const employerSelect = this.filterElements.employer;
                if (!employerSelect) return;

                // Clear existing options except the first one
                employerSelect.innerHTML = '<option value="">All Employers</option>';

                // Get unique employers (limit to top 50 for performance)
                const employers = this.getUniqueValues(data, 'EMPLOYER_NAME', 50);

                employers.forEach(employer => {
                    const option = document.createElement('option');
                    option.value = employer;
                    option.textContent = employer;
                    employerSelect.appendChild(option);
                });

                console.log(`Populated employer filter with ${employers.length} options`);
            }

            /**
             * Populate status dropdown filter
             */
            populateStatusFilter(data) {
                const statusSelect = this.filterElements.status;
                if (!statusSelect) return;

                // Clear existing options except the first one
                statusSelect.innerHTML = '<option value="">All Statuses</option>';

                // Get unique statuses using normalized status field
                const statuses = this.getUniqueValues(data, 'CASE_STATUS_NORMALIZED');

                statuses.forEach(status => {
                    const option = document.createElement('option');
                    option.value = status;
                    option.textContent = status;
                    statusSelect.appendChild(option);
                });

                console.log(`Populated status filter with ${statuses.length} options`);
            }

            /**
             * Populate job title dropdown filter
             */
            populateJobTitleFilter(data) {
                const jobTitleSelect = this.filterElements.jobTitle;
                if (!jobTitleSelect) return;

                // Clear existing options except the first one
                jobTitleSelect.innerHTML = '<option value="">All Job Titles</option>';

                // Get unique job titles (limit to top 30 for performance)
                const jobTitles = this.getUniqueValues(data, 'JOB_TITLE', 30);

                jobTitles.forEach(jobTitle => {
                    const option = document.createElement('option');
                    option.value = jobTitle;
                    option.textContent = jobTitle.length > 50 ?
                        jobTitle.substring(0, 50) + '...' : jobTitle;
                    jobTitleSelect.appendChild(option);
                });

                console.log(`Populated job title filter with ${jobTitles.length} options`);
            }

            /**
             * Set up event listeners for filter controls
             */
            setupEventListeners() {
                // Employer filter
                if (this.filterElements.employer) {
                    this.filterElements.employer.addEventListener('change', (e) => {
                        this.updateFilter('employer', e.target.value);
                    });
                }

                // Status filter
                if (this.filterElements.status) {
                    this.filterElements.status.addEventListener('change', (e) => {
                        this.updateFilter('status', e.target.value);
                    });
                }

                // Job title filter
                if (this.filterElements.jobTitle) {
                    this.filterElements.jobTitle.addEventListener('change', (e) => {
                        this.updateFilter('jobTitle', e.target.value);
                    });
                }

                // Salary range filters
                if (this.filterElements.minSalary) {
                    this.filterElements.minSalary.addEventListener('input', (e) => {
                        const value = e.target.value ? parseFloat(e.target.value) : null;
                        this.updateFilter('minSalary', value);
                    });
                }

                if (this.filterElements.maxSalary) {
                    this.filterElements.maxSalary.addEventListener('input', (e) => {
                        const value = e.target.value ? parseFloat(e.target.value) : null;
                        this.updateFilter('maxSalary', value);
                    });
                }

                // Search input with debouncing
                if (this.filterElements.searchInput) {
                    let searchTimeout;
                    this.filterElements.searchInput.addEventListener('input', (e) => {
                        clearTimeout(searchTimeout);
                        searchTimeout = setTimeout(() => {
                            this.updateFilter('searchTerm', e.target.value);
                        }, 300); // 300ms debounce
                    });
                }

                // Clear filters button
                if (this.filterElements.clearButton) {
                    this.filterElements.clearButton.addEventListener('click', () => {
                        this.clearFilters();
                    });
                }

                console.log('Filter event listeners set up');
            }

            /**
             * Update a specific filter and apply all filters
             */
            updateFilter(filterName, value) {
                // Validate salary range
                if (filterName === 'minSalary' || filterName === 'maxSalary') {
                    if (value !== null && (isNaN(value) || value < 0)) {
                        console.warn(`Invalid ${filterName} value: ${value}`);
                        return;
                    }
                }

                // Update filter state
                this.filterState[filterName] = value;

                // Apply filters through DataManager
                this.applyFilters();

                console.log(`Updated ${filterName} filter:`, value);
            }

            /**
             * Apply all current filters using DataManager
             */
            applyFilters() {
                if (!this.dataManager) {
                    console.error('DataManager not available for filtering');
                    return;
                }

                // Apply filters through DataManager
                const filteredData = this.dataManager.applyFilters(this.filterState);

                // Trigger custom event for other components to respond
                const filterEvent = new CustomEvent('filtersApplied', {
                    detail: {
                        filterState: { ...this.filterState },
                        filteredData: filteredData,
                        totalRecords: filteredData.length
                    }
                });
                document.dispatchEvent(filterEvent);

                return filteredData;
            }

            /**
             * Clear all filters and reset UI controls
             */
            clearFilters() {
                // Reset filter state
                this.filterState = {
                    employer: '',
                    status: '',
                    jobTitle: '',
                    minSalary: null,
                    maxSalary: null,
                    searchTerm: ''
                };

                // Reset UI controls
                if (this.filterElements.employer) {
                    this.filterElements.employer.value = '';
                }
                if (this.filterElements.status) {
                    this.filterElements.status.value = '';
                }
                if (this.filterElements.jobTitle) {
                    this.filterElements.jobTitle.value = '';
                }
                if (this.filterElements.minSalary) {
                    this.filterElements.minSalary.value = '';
                }
                if (this.filterElements.maxSalary) {
                    this.filterElements.maxSalary.value = '';
                }
                if (this.filterElements.searchInput) {
                    this.filterElements.searchInput.value = '';
                }

                // Clear filters in DataManager
                if (this.dataManager) {
                    this.dataManager.clearFilters();
                }

                // Apply cleared filters
                this.applyFilters();

                console.log('All filters cleared');
            }

            /**
             * Get current filter state
             */
            getFilterState() {
                return { ...this.filterState };
            }

            /**
             * Set filter state programmatically
             */
            setFilterState(newState) {
                this.filterState = { ...this.filterState, ...newState };
                this.updateUIFromState();
                this.applyFilters();
            }

            /**
             * Update UI controls to match current filter state
             */
            updateUIFromState() {
                if (this.filterElements.employer) {
                    this.filterElements.employer.value = this.filterState.employer || '';
                }
                if (this.filterElements.status) {
                    this.filterElements.status.value = this.filterState.status || '';
                }
                if (this.filterElements.jobTitle) {
                    this.filterElements.jobTitle.value = this.filterState.jobTitle || '';
                }
                if (this.filterElements.minSalary) {
                    this.filterElements.minSalary.value = this.filterState.minSalary || '';
                }
                if (this.filterElements.maxSalary) {
                    this.filterElements.maxSalary.value = this.filterState.maxSalary || '';
                }
                if (this.filterElements.searchInput) {
                    this.filterElements.searchInput.value = this.filterState.searchTerm || '';
                }
            }

            /**
             * Get filter summary for display
             */
            getFilterSummary() {
                const activeFilters = [];

                if (this.filterState.employer) {
                    activeFilters.push(`Employer: ${this.filterState.employer}`);
                }
                if (this.filterState.status) {
                    activeFilters.push(`Status: ${this.filterState.status}`);
                }
                if (this.filterState.jobTitle) {
                    activeFilters.push(`Job Title: ${this.filterState.jobTitle}`);
                }
                if (this.filterState.minSalary !== null) {
                    activeFilters.push(`Min Salary: $${this.filterState.minSalary.toLocaleString()}`);
                }
                if (this.filterState.maxSalary !== null) {
                    activeFilters.push(`Max Salary: $${this.filterState.maxSalary.toLocaleString()}`);
                }
                if (this.filterState.searchTerm) {
                    activeFilters.push(`Search: "${this.filterState.searchTerm}"`);
                }

                return {
                    activeFilters,
                    hasActiveFilters: activeFilters.length > 0,
                    filterCount: activeFilters.length
                };
            }

            /**
             * Validate filter state for consistency
             */
            validateFilters() {
                const errors = [];

                // Check salary range consistency
                if (this.filterState.minSalary !== null && this.filterState.maxSalary !== null) {
                    if (this.filterState.minSalary > this.filterState.maxSalary) {
                        errors.push('Minimum salary cannot be greater than maximum salary');
                    }
                }

                // Check for negative salary values
                if (this.filterState.minSalary !== null && this.filterState.minSalary < 0) {
                    errors.push('Minimum salary cannot be negative');
                }
                if (this.filterState.maxSalary !== null && this.filterState.maxSalary < 0) {
                    errors.push('Maximum salary cannot be negative');
                }

                return {
                    isValid: errors.length === 0,
                    errors
                };
            }

            /**
             * Check if filters are initialized
             */
            isInitialized() {
                return this.initialized;
            }
        }

        /**
         * Data fetching and loading functionality
         */
        class DataLoader {
            constructor() {
                this.isLoading = false;
                this.loadingCallbacks = [];
                this.errorCallbacks = [];
                this.successCallbacks = [];
            }

            /**
             * Add callback for loading state changes
             */
            onLoadingChange(callback) {
                this.loadingCallbacks.push(callback);
            }

            /**
             * Add callback for errors
             */
            onError(callback) {
                this.errorCallbacks.push(callback);
            }

            /**
             * Add callback for successful data load
             */
            onSuccess(callback) {
                this.successCallbacks.push(callback);
            }

            /**
             * Set loading state and notify callbacks
             */
            setLoading(loading) {
                this.isLoading = loading;
                this.loadingCallbacks.forEach(callback => callback(loading));
            }

            /**
             * Trigger error callbacks
             */
            triggerError(error) {
                this.errorCallbacks.forEach(callback => callback(error));
            }

            /**
             * Trigger success callbacks
             */
            triggerSuccess(data) {
                this.successCallbacks.forEach(callback => callback(data));
            }

            /**
             * Fetch H1B data from Supabase database only
             */
            async fetchH1BData() {
                this.setLoading(true);

                try {
                    // Check if Supabase client is available
                    if (!supabaseClient) {
                        throw new Error('Supabase client not initialized. Please check your configuration.');
                    }

                    console.log('ðŸ”„ Fetching H1B data from Supabase database...');
                    return await this.fetchFromSupabase();

                } catch (error) {
                    this.setLoading(false);

                    let errorMessage = 'Failed to load H1B data from database';
                    let userFriendlyMessage = 'Unable to load H1B data from the database. Please try again.';

                    if (error.name === 'AbortError') {
                        errorMessage = 'Database request timed out';
                        userFriendlyMessage = 'The database request took too long. Please check your connection and try again.';
                    } else if (error.message.includes('not initialized')) {
                        errorMessage = 'Database not configured';
                        userFriendlyMessage = 'The database connection is not properly configured. Please check your settings.';
                    } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
                        errorMessage = 'Network error';
                        userFriendlyMessage = 'Unable to connect to the database. Please check your internet connection.';
                    } else if (error.message.includes('Supabase') || error.message.includes('database')) {
                        errorMessage = 'Database connection error';
                        userFriendlyMessage = 'Unable to connect to the database. Please check your configuration.';
                    }

                    console.error('âŒ Database loading error:', error);

                    const errorInfo = {
                        message: errorMessage,
                        userMessage: userFriendlyMessage,
                        originalError: error
                    };

                    this.triggerError(errorInfo);
                    throw errorInfo;
                }
            }

            /**
             * Fetch H1B data from Supabase database
             */
            async fetchFromSupabase() {
                try {
                    console.log('ðŸ”„ Loading H1B data from Supabase database...');

                    // First, get the total count
                    const { count: totalCount, error: countError } = await supabaseClient
                        .from(SUPABASE_CONFIG.tableName)
                        .select('*', { count: 'exact', head: true });

                    if (countError) {
                        throw new Error(`Supabase count error: ${countError.message}`);
                    }

                    console.log(`ðŸ“Š Total records in database: ${totalCount}`);

                    // Fetch data with a reasonable limit for performance
                    const limit = Math.min(totalCount || 5000, 5000); // Max 5000 records for performance

                    const { data, error } = await supabaseClient
                        .from(SUPABASE_CONFIG.tableName)
                        .select('*')
                        .order('created_at', { ascending: false }) // Get newest records first
                        .limit(limit);

                    if (error) {
                        throw new Error(`Supabase fetch error: ${error.message}`);
                    }

                    if (!data || !Array.isArray(data)) {
                        throw new Error('Invalid data format from Supabase: Expected an array of H1B records');
                    }

                    if (data.length === 0) {
                        throw new Error('No H1B records found in the database. Please upload data first.');
                    }

                    console.log(`âœ… Successfully loaded ${data.length} H1B records from Supabase`);

                    // Convert Supabase data format to match expected format
                    const convertedData = data.map(record => this.convertSupabaseRecord(record));

                    // Validate converted data
                    const validRecords = convertedData.filter(record =>
                        record.CASE_NUMBER && record.EMPLOYER_NAME && record.JOB_TITLE
                    );

                    if (validRecords.length === 0) {
                        throw new Error('No valid H1B records found after conversion');
                    }

                    console.log(`âœ… Converted and validated ${validRecords.length} records`);

                    this.setLoading(false);
                    this.triggerSuccess(validRecords);

                    return validRecords;

                } catch (error) {
                    console.error('âŒ Supabase fetch error:', error);
                    throw new Error(`Supabase database error: ${error.message}`);
                }
            }

            /**
             * Convert Supabase record format to match expected JSON format
             */
            convertSupabaseRecord(record) {
                // Convert snake_case database fields to UPPER_CASE JSON format
                const converted = {};

                // Essential field mappings based on our simplified table schema
                const fieldMapping = {
                    'case_number': 'CASE_NUMBER',
                    'case_status': 'CASE_STATUS',
                    'received_date': 'RECEIVED_DATE',
                    'decision_date': 'DECISION_DATE',
                    'visa_class': 'VISA_CLASS',
                    'job_title': 'JOB_TITLE',
                    'soc_code': 'SOC_CODE',
                    'soc_title': 'SOC_TITLE',
                    'full_time_position': 'FULL_TIME_POSITION',
                    'begin_date': 'BEGIN_DATE',
                    'end_date': 'END_DATE',
                    'employer_name': 'EMPLOYER_NAME',
                    'employer_city': 'EMPLOYER_CITY',
                    'employer_state': 'EMPLOYER_STATE',
                    'employer_postal_code': 'EMPLOYER_POSTAL_CODE',
                    'worksite_city': 'WORKSITE_CITY',
                    'worksite_state': 'WORKSITE_STATE',
                    'worksite_postal_code': 'WORKSITE_POSTAL_CODE',
                    'wage_rate_of_pay_from': 'WAGE_RATE_OF_PAY_FROM',
                    'wage_rate_of_pay_to': 'WAGE_RATE_OF_PAY_TO',
                    'wage_unit_of_pay': 'WAGE_UNIT_OF_PAY',
                    'prevailing_wage': 'PREVAILING_WAGE'
                };

                // Convert fields with proper handling
                for (const [dbField, jsonField] of Object.entries(fieldMapping)) {
                    if (record.hasOwnProperty(dbField)) {
                        let value = record[dbField];

                        // Handle null values
                        if (value === null || value === undefined) {
                            converted[jsonField] = null;
                        }
                        // Handle date fields - ensure they're in ISO format
                        else if (dbField.includes('_date') && value) {
                            try {
                                // If it's already a date object, convert to ISO string
                                if (value instanceof Date) {
                                    converted[jsonField] = value.toISOString();
                                } else if (typeof value === 'string') {
                                    // Ensure it's a valid date string
                                    const date = new Date(value);
                                    converted[jsonField] = isNaN(date.getTime()) ? null : date.toISOString();
                                } else {
                                    converted[jsonField] = null;
                                }
                            } catch (e) {
                                converted[jsonField] = null;
                            }
                        }
                        // Handle numeric fields
                        else if (dbField.includes('wage') || dbField.includes('prevailing')) {
                            converted[jsonField] = value !== null ? Number(value) : null;
                        }
                        // Handle string fields
                        else {
                            converted[jsonField] = value;
                        }
                    } else {
                        // Set default null for missing fields
                        converted[jsonField] = null;
                    }
                }

                // Create location field for compatibility
                if (converted.WORKSITE_CITY && converted.WORKSITE_STATE) {
                    converted.LOCATION = `${converted.WORKSITE_CITY}, ${converted.WORKSITE_STATE}`;
                } else if (converted.WORKSITE_CITY) {
                    converted.LOCATION = converted.WORKSITE_CITY;
                } else if (converted.WORKSITE_STATE) {
                    converted.LOCATION = converted.WORKSITE_STATE;
                } else {
                    converted.LOCATION = 'N/A';
                }

                return converted;
            }



            /**
             * Retry data loading with exponential backoff
             */
            async retryFetch(maxRetries = 3, baseDelay = 1000) {
                let lastError;

                for (let attempt = 1; attempt <= maxRetries; attempt++) {
                    try {
                        console.log(`Attempt ${attempt} of ${maxRetries} to load data from Supabase`);
                        return await this.fetchH1BData();
                    } catch (error) {
                        lastError = error;

                        if (attempt < maxRetries) {
                            const delay = baseDelay * Math.pow(2, attempt - 1); // Exponential backoff
                            console.log(`Retrying in ${delay}ms...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }

                throw lastError;
            }
        }

        /**
         * TableRenderer class for rendering H1B data table with sorting and responsive design
         * Handles table header rendering, row rendering, and responsive table structure
         */
        class TableRenderer {
            constructor(tableId = 'dataTable', tableBodyId = 'tableBody') {
                this.tableElement = document.getElementById(tableId);
                this.tableBodyElement = document.getElementById(tableBodyId);
                this.currentSort = {
                    column: null,
                    direction: 'asc'
                };

                // Define table columns configuration
                this.columns = [
                    { key: 'CASE_NUMBER', label: 'Case Number', sortable: true, type: 'text' },
                    { key: 'EMPLOYER_NAME', label: 'Employer', sortable: true, type: 'text' },
                    { key: 'JOB_TITLE', label: 'Job Title', sortable: true, type: 'text' },
                    { key: 'CASE_STATUS', label: 'Status', sortable: true, type: 'status' },
                    { key: 'WAGE_RATE_OF_PAY_FROM', label: 'Salary', sortable: true, type: 'currency' },
                    { key: 'LOCATION', label: 'Location', sortable: true, type: 'text' },
                    { key: 'DECISION_DATE', label: 'Decision Date', sortable: true, type: 'date' }
                ];

                this.initializeEventListeners();
            }

            /**
             * Initialize event listeners for table interactions
             */
            initializeEventListeners() {
                if (this.tableElement) {
                    // Add click listeners to sortable column headers
                    const headers = this.tableElement.querySelectorAll('th.sortable');
                    headers.forEach(header => {
                        header.addEventListener('click', (e) => {
                            const column = e.target.getAttribute('data-column');
                            if (column) {
                                this.handleSort(column);
                            }
                        });
                    });
                }
            }

            /**
             * Handle column sorting
             */
            handleSort(column) {
                // Toggle sort direction if same column, otherwise default to ascending
                if (this.currentSort.column === column) {
                    this.currentSort.direction = this.currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    this.currentSort.column = column;
                    this.currentSort.direction = 'asc';
                }

                // Update visual indicators
                this.updateSortIndicators();

                // Trigger sort event (will be handled by main application)
                const sortEvent = new CustomEvent('tableSort', {
                    detail: {
                        column: this.currentSort.column,
                        direction: this.currentSort.direction
                    }
                });
                document.dispatchEvent(sortEvent);
            }

            /**
             * Update visual sort indicators in table headers
             */
            updateSortIndicators() {
                const headers = this.tableElement.querySelectorAll('th.sortable');
                headers.forEach(header => {
                    const column = header.getAttribute('data-column');

                    // Remove existing sort classes
                    header.classList.remove('sort-asc', 'sort-desc');

                    // Reset aria-sort attribute
                    header.setAttribute('aria-sort', 'none');

                    // Add appropriate sort class and aria-sort if this is the active column
                    if (column === this.currentSort.column) {
                        header.classList.add(`sort-${this.currentSort.direction}`);
                        header.setAttribute('aria-sort', this.currentSort.direction === 'asc' ? 'ascending' : 'descending');

                        // Update title for better accessibility
                        const nextDirection = this.currentSort.direction === 'asc' ? 'descending' : 'ascending';
                        header.setAttribute('title', `Sort by ${header.textContent} (${nextDirection})`);
                    } else {
                        header.setAttribute('title', `Sort by ${header.textContent}`);
                    }
                });
            }

            /**
             * Render complete table with data
             */
            renderTable(data, currentPage = 1, totalPages = 1) {
                if (!this.tableBodyElement) {
                    console.error('Table body element not found');
                    return;
                }

                // Clear existing content
                this.tableBodyElement.innerHTML = '';

                // Handle empty data
                if (!data || data.length === 0) {
                    this.renderEmptyState();
                    return;
                }

                // Render table rows
                this.renderTableRows(data);

                // Update table accessibility
                this.updateTableAccessibility(data.length);
            }

            /**
             * Render table header with sortable columns
             */
            renderTableHeader() {
                const thead = this.tableElement.querySelector('thead tr');
                if (!thead) {
                    console.error('Table header not found');
                    return;
                }

                // Clear existing headers
                thead.innerHTML = '';

                // Create header cells
                this.columns.forEach(column => {
                    const th = document.createElement('th');
                    th.textContent = column.label;
                    th.setAttribute('data-column', column.key);

                    if (column.sortable) {
                        th.classList.add('sortable');
                        th.setAttribute('role', 'columnheader');
                        th.setAttribute('tabindex', '0');
                        th.setAttribute('aria-sort', 'none');

                        // Add keyboard support
                        th.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                this.handleSort(column.key);
                            }
                        });
                    }

                    thead.appendChild(th);
                });

                // Update sort indicators
                this.updateSortIndicators();
            }

            /**
             * Render table rows for H1B application data
             */
            renderTableRows(data) {
                const fragment = document.createDocumentFragment();

                data.forEach((record, index) => {
                    const row = document.createElement('tr');
                    row.setAttribute('data-case-number', record.CASE_NUMBER);
                    row.setAttribute('role', 'row');
                    row.setAttribute('tabindex', '0');

                    // Add click handler for row details
                    row.addEventListener('click', () => {
                        const detailEvent = new CustomEvent('rowClick', {
                            detail: { record, index }
                        });
                        document.dispatchEvent(detailEvent);
                    });

                    // Add keyboard support
                    row.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            row.click();
                        }
                    });

                    // Create cells for each column
                    this.columns.forEach(column => {
                        const cell = document.createElement('td');
                        cell.setAttribute('role', 'gridcell');

                        const value = this.getCellValue(record, column);
                        const formattedValue = this.formatCellValue(value, column.type, record);

                        if (column.type === 'status') {
                            cell.innerHTML = formattedValue;
                        } else {
                            cell.textContent = formattedValue;
                        }

                        row.appendChild(cell);
                    });

                    fragment.appendChild(row);
                });

                this.tableBodyElement.appendChild(fragment);
            }

            /**
             * Get cell value from record based on column configuration
             */
            getCellValue(record, column) {
                switch (column.key) {
                    case 'LOCATION':
                        return record.LOCATION || this.formatLocation(record.WORKSITE_CITY, record.WORKSITE_STATE);
                    case 'WAGE_RATE_OF_PAY_FROM':
                        return record.ANNUAL_SALARY || record.WAGE_RATE_OF_PAY_FROM;
                    default:
                        return record[column.key] || '';
                }
            }

            /**
             * Format cell value based on column type
             */
            formatCellValue(value, type, record) {
                if (!value || value === '' || value === 'N/A') {
                    return 'N/A';
                }

                switch (type) {
                    case 'currency':
                        return this.formatCurrency(value);
                    case 'date':
                        return this.formatDate(value);
                    case 'status':
                        return this.formatStatus(value);
                    case 'text':
                    default:
                        return String(value);
                }
            }

            /**
             * Format currency values
             */
            formatCurrency(amount) {
                if (!amount || isNaN(amount)) return 'N/A';

                const numAmount = parseFloat(amount);
                if (numAmount === 0) return 'N/A';

                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(numAmount);
            }

            /**
             * Format date values
             */
            formatDate(dateValue) {
                if (!dateValue) return 'N/A';

                try {
                    const date = new Date(dateValue);
                    if (isNaN(date.getTime())) return 'N/A';

                    return new Intl.DateTimeFormat('en-US', {
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric'
                    }).format(date);
                } catch (error) {
                    return 'N/A';
                }
            }

            /**
             * Format status with color-coded badge
             */
            formatStatus(status) {
                if (!status) return '<span class="status-badge">Unknown</span>';

                const statusLower = status.toLowerCase();
                let statusClass = 'status-badge';

                if (statusLower.includes('certified')) {
                    statusClass += ' status-certified';
                } else if (statusLower.includes('denied')) {
                    statusClass += ' status-denied';
                } else if (statusLower.includes('withdrawn')) {
                    statusClass += ' status-withdrawn';
                }

                return `<span class="${statusClass}">${status}</span>`;
            }

            /**
             * Format location from city and state
             */
            formatLocation(city, state) {
                const cityStr = (city || '').trim();
                const stateStr = (state || '').trim();

                if (cityStr && stateStr) {
                    return `${cityStr}, ${stateStr}`;
                } else if (cityStr) {
                    return cityStr;
                } else if (stateStr) {
                    return stateStr;
                } else {
                    return 'N/A';
                }
            }

            /**
             * Render empty state when no data is available
             */
            renderEmptyState() {
                this.tableBodyElement.innerHTML = `
                    <tr>
                        <td colspan="${this.columns.length}" class="empty-state">
                            <h3>No H1B Applications Found</h3>
                            <p>Try adjusting your filters or search criteria to see results.</p>
                        </td>
                    </tr>
                `;
            }

            /**
             * Update table accessibility attributes
             */
            updateTableAccessibility(rowCount) {
                if (this.tableElement) {
                    this.tableElement.setAttribute('role', 'grid');
                    this.tableElement.setAttribute('aria-rowcount', rowCount + 1); // +1 for header
                    this.tableElement.setAttribute('aria-label', `H1B Applications Table with ${rowCount} records`);
                }
            }

            /**
             * Get current sort configuration
             */
            getCurrentSort() {
                return { ...this.currentSort };
            }

            /**
             * Set sort configuration (useful for external control)
             */
            setSort(column, direction) {
                this.currentSort.column = column;
                this.currentSort.direction = direction;
                this.updateSortIndicators();
            }

            /**
             * Create responsive table structure for mobile devices
             */
            createResponsiveTable(data) {
                // This method can be extended for mobile card-based layout
                // For now, the CSS handles responsive behavior
                return this.renderTable(data);
            }
        }

        /**
         * PaginationRenderer class for handling pagination controls and logic
         * Manages page navigation, page size, and pagination display
         */
        class PaginationRenderer {
            constructor(paginationId = 'pagination') {
                this.paginationElement = document.getElementById(paginationId);
                this.currentPage = 1;
                this.totalPages = 1;
                this.pageSize = 50; // Default page size as per requirements
                this.totalRecords = 0;
                this.maxVisiblePages = 5; // Maximum number of page buttons to show

                this.initializeEventListeners();
            }

            /**
             * Initialize event listeners for pagination controls
             */
            initializeEventListeners() {
                // Event delegation for pagination buttons
                if (this.paginationElement) {
                    this.paginationElement.addEventListener('click', (e) => {
                        if (e.target.matches('.pagination-btn')) {
                            e.preventDefault();
                            const action = e.target.getAttribute('data-action');
                            const page = parseInt(e.target.getAttribute('data-page'));

                            this.handlePaginationClick(action, page);
                        }
                    });
                }
            }

            /**
             * Handle pagination button clicks
             */
            handlePaginationClick(action, page) {
                let newPage = this.currentPage;

                switch (action) {
                    case 'first':
                        newPage = 1;
                        break;
                    case 'prev':
                        newPage = Math.max(1, this.currentPage - 1);
                        break;
                    case 'next':
                        newPage = Math.min(this.totalPages, this.currentPage + 1);
                        break;
                    case 'last':
                        newPage = this.totalPages;
                        break;
                    case 'page':
                        newPage = page;
                        break;
                }

                if (newPage !== this.currentPage && newPage >= 1 && newPage <= this.totalPages) {
                    this.goToPage(newPage);
                }
            }

            /**
             * Navigate to a specific page
             */
            goToPage(page) {
                if (page < 1 || page > this.totalPages) {
                    console.warn(`Invalid page number: ${page}. Must be between 1 and ${this.totalPages}`);
                    return;
                }

                this.currentPage = page;
                this.renderPagination();

                // Trigger page change event
                const pageChangeEvent = new CustomEvent('pageChange', {
                    detail: {
                        page: this.currentPage,
                        pageSize: this.pageSize,
                        totalPages: this.totalPages,
                        totalRecords: this.totalRecords
                    }
                });
                document.dispatchEvent(pageChangeEvent);
            }

            /**
             * Update pagination state and render controls
             */
            updatePagination(currentPage, totalPages, totalRecords, pageSize = 50) {
                this.currentPage = Math.max(1, Math.min(currentPage, totalPages));
                this.totalPages = Math.max(1, totalPages);
                this.totalRecords = Math.max(0, totalRecords);
                this.pageSize = Math.max(1, pageSize);

                this.renderPagination();
            }

            /**
             * Render pagination controls
             */
            renderPagination() {
                if (!this.paginationElement) {
                    console.error('Pagination element not found');
                    return;
                }

                // Clear existing content
                this.paginationElement.innerHTML = '';

                // Don't show pagination if there's only one page or no data
                if (this.totalPages <= 1) {
                    this.paginationElement.style.display = 'none';
                    return;
                }

                this.paginationElement.style.display = 'flex';

                // Create pagination container
                const paginationContainer = document.createElement('div');
                paginationContainer.className = 'pagination-controls';
                paginationContainer.setAttribute('role', 'navigation');
                paginationContainer.setAttribute('aria-label', 'Pagination Navigation');

                // Add pagination info
                const paginationInfo = this.createPaginationInfo();
                paginationContainer.appendChild(paginationInfo);

                // Add navigation buttons
                const navigationButtons = this.createNavigationButtons();
                paginationContainer.appendChild(navigationButtons);

                // Add page size selector (optional enhancement)
                const pageSizeSelector = this.createPageSizeSelector();
                paginationContainer.appendChild(pageSizeSelector);

                this.paginationElement.appendChild(paginationContainer);
            }

            /**
             * Create pagination information display
             */
            createPaginationInfo() {
                const info = document.createElement('div');
                info.className = 'pagination-info';

                const startRecord = (this.currentPage - 1) * this.pageSize + 1;
                const endRecord = Math.min(this.currentPage * this.pageSize, this.totalRecords);

                info.textContent = `Showing ${startRecord}-${endRecord} of ${this.totalRecords.toLocaleString()} records`;
                info.setAttribute('aria-live', 'polite');

                return info;
            }

            /**
             * Create navigation buttons (previous, page numbers, next)
             */
            createNavigationButtons() {
                const nav = document.createElement('div');
                nav.className = 'pagination-nav';

                // First page button
                if (this.currentPage > 1) {
                    nav.appendChild(this.createButton('first', 'Â«', 'First page'));
                }

                // Previous page button
                nav.appendChild(this.createButton(
                    'prev',
                    'â€¹',
                    'Previous page',
                    this.currentPage <= 1
                ));

                // Page number buttons
                const pageButtons = this.createPageButtons();
                pageButtons.forEach(button => nav.appendChild(button));

                // Next page button
                nav.appendChild(this.createButton(
                    'next',
                    'â€º',
                    'Next page',
                    this.currentPage >= this.totalPages
                ));

                // Last page button
                if (this.currentPage < this.totalPages) {
                    nav.appendChild(this.createButton('last', 'Â»', 'Last page'));
                }

                return nav;
            }

            /**
             * Create page number buttons with smart truncation
             */
            createPageButtons() {
                const buttons = [];
                const startPage = Math.max(1, this.currentPage - Math.floor(this.maxVisiblePages / 2));
                const endPage = Math.min(this.totalPages, startPage + this.maxVisiblePages - 1);
                const adjustedStartPage = Math.max(1, endPage - this.maxVisiblePages + 1);

                // Add first page and ellipsis if needed
                if (adjustedStartPage > 1) {
                    buttons.push(this.createButton('page', '1', 'Go to page 1', false, 1));
                    if (adjustedStartPage > 2) {
                        buttons.push(this.createEllipsis());
                    }
                }

                // Add page number buttons
                for (let page = adjustedStartPage; page <= endPage; page++) {
                    const isActive = page === this.currentPage;
                    buttons.push(this.createButton(
                        'page',
                        page.toString(),
                        `Go to page ${page}`,
                        false,
                        page,
                        isActive
                    ));
                }

                // Add ellipsis and last page if needed
                if (endPage < this.totalPages) {
                    if (endPage < this.totalPages - 1) {
                        buttons.push(this.createEllipsis());
                    }
                    buttons.push(this.createButton(
                        'page',
                        this.totalPages.toString(),
                        `Go to page ${this.totalPages}`,
                        false,
                        this.totalPages
                    ));
                }

                return buttons;
            }

            /**
             * Create a pagination button
             */
            createButton(action, text, ariaLabel, disabled = false, page = null, active = false) {
                const button = document.createElement('button');
                button.className = `pagination-btn ${active ? 'active' : ''}`;
                button.textContent = text;
                button.setAttribute('data-action', action);
                button.setAttribute('aria-label', ariaLabel);
                button.disabled = disabled;

                if (page !== null) {
                    button.setAttribute('data-page', page);
                }

                if (active) {
                    button.setAttribute('aria-current', 'page');
                }

                return button;
            }

            /**
             * Create ellipsis indicator
             */
            createEllipsis() {
                const ellipsis = document.createElement('span');
                ellipsis.className = 'pagination-ellipsis';
                ellipsis.textContent = 'â€¦';
                ellipsis.setAttribute('aria-hidden', 'true');
                return ellipsis;
            }

            /**
             * Create page size selector
             */
            createPageSizeSelector() {
                const container = document.createElement('div');
                container.className = 'page-size-selector';

                const label = document.createElement('label');
                label.textContent = 'Show: ';
                label.setAttribute('for', 'pageSizeSelect');

                const select = document.createElement('select');
                select.id = 'pageSizeSelect';
                select.className = 'page-size-select';

                const pageSizes = [25, 50, 100, 200];
                pageSizes.forEach(size => {
                    const option = document.createElement('option');
                    option.value = size;
                    option.textContent = `${size} per page`;
                    option.selected = size === this.pageSize;
                    select.appendChild(option);
                });

                select.addEventListener('change', (e) => {
                    const newPageSize = parseInt(e.target.value);
                    this.changePageSize(newPageSize);
                });

                container.appendChild(label);
                container.appendChild(select);

                return container;
            }

            /**
             * Change page size and adjust current page accordingly
             */
            changePageSize(newPageSize) {
                if (newPageSize === this.pageSize) return;

                // Calculate what the first record on current page is
                const currentFirstRecord = (this.currentPage - 1) * this.pageSize + 1;

                // Update page size
                this.pageSize = newPageSize;

                // Calculate new total pages
                this.totalPages = Math.ceil(this.totalRecords / this.pageSize);

                // Calculate new current page to show the same first record
                this.currentPage = Math.ceil(currentFirstRecord / this.pageSize);
                this.currentPage = Math.max(1, Math.min(this.currentPage, this.totalPages));

                // Trigger page size change event
                const pageSizeChangeEvent = new CustomEvent('pageSizeChange', {
                    detail: {
                        pageSize: this.pageSize,
                        page: this.currentPage,
                        totalPages: this.totalPages,
                        totalRecords: this.totalRecords
                    }
                });
                document.dispatchEvent(pageSizeChangeEvent);

                this.renderPagination();
            }

            /**
             * Get current pagination state
             */
            getPaginationState() {
                return {
                    currentPage: this.currentPage,
                    totalPages: this.totalPages,
                    pageSize: this.pageSize,
                    totalRecords: this.totalRecords,
                    startRecord: (this.currentPage - 1) * this.pageSize + 1,
                    endRecord: Math.min(this.currentPage * this.pageSize, this.totalRecords)
                };
            }

            /**
             * Calculate pagination data for a given dataset
             */
            static calculatePagination(totalRecords, currentPage = 1, pageSize = 50) {
                const totalPages = Math.ceil(totalRecords / pageSize);
                const validCurrentPage = Math.max(1, Math.min(currentPage, totalPages));
                const startIndex = (validCurrentPage - 1) * pageSize;
                const endIndex = Math.min(startIndex + pageSize, totalRecords);

                return {
                    currentPage: validCurrentPage,
                    totalPages,
                    pageSize,
                    totalRecords,
                    startIndex,
                    endIndex,
                    hasNextPage: validCurrentPage < totalPages,
                    hasPreviousPage: validCurrentPage > 1
                };
            }

            /**
             * Slice data array for current page
             */
            static sliceDataForPage(data, currentPage = 1, pageSize = 50) {
                const startIndex = (currentPage - 1) * pageSize;
                const endIndex = startIndex + pageSize;
                return data.slice(startIndex, endIndex);
            }
        }

        /**
         * Application state and initialization
         */
        let dataManager = null;
        let dataLoader = null;
        let tableRenderer = null;
        let paginationRenderer = null;
        let filterManager = null;

        // Initialize application
        console.log('H1B Data Viewer initialized');

        /**
         * Initialize the application and load data
         */
        async function initializeApp() {
            // Create data loader instance
            dataLoader = new DataLoader();

            // Set up loading state management
            dataLoader.onLoadingChange((isLoading) => {
                updateLoadingState(isLoading);
            });

            // Set up error handling
            dataLoader.onError((error) => {
                updateDataSourceStatus('error', `Failed to load data: ${error.userMessage}`, true);
                showError(error.userMessage, error.message);
            });

            // Set up success handling
            dataLoader.onSuccess((data) => {
                // Create DataManager with loaded data
                dataManager = new DataManager(data);
                console.log('Data processing complete');

                // Update data source status - always Supabase
                updateDataSourceStatus('supabase', `Supabase Database (${data.length} records loaded)`);

                // Initialize UI components
                initializeUIComponents();

                // Render initial data
                renderApplication();

                console.log(`Successfully loaded and rendered ${data.length} H1B records from Supabase`);
            });

            // Start loading data
            try {
                await dataLoader.fetchH1BData();
            } catch (error) {
                // Error is already handled by the error callback
                console.error('Failed to initialize app:', error);
            }
        }

        /**
         * Update loading state in the UI
         */
        function updateLoadingState(isLoading) {
            const tableBody = document.getElementById('tableBody');
            const statsGrid = document.getElementById('statsGrid');

            if (isLoading) {
                // Update data source status for Supabase only
                updateDataSourceStatus('supabase', 'Loading data from Supabase database...');

                // Show loading in table
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="7" class="loading">
                            <div class="spinner"></div>
                            Loading H1B application data from database...
                        </td>
                    </tr>
                `;

                // Show loading in stats
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="loading">
                            <div class="spinner"></div>
                            Loading statistics from database...
                        </div>
                    </div>
                `;
            }
        }

        /**
         * Show error message in the UI
         */
        function showError(userMessage, technicalMessage) {
            const tableBody = document.getElementById('tableBody');
            const statsGrid = document.getElementById('statsGrid');

            // Show error in table
            tableBody.innerHTML = `
                <tr>
                    <td colspan="7">
                        <div class="error">
                            <h3>Error Loading Data from Supabase</h3>
                            <p>${userMessage}</p>
                            ${!supabaseClient ?
                    '<p><strong>Configuration Issue:</strong> Supabase client is not properly initialized. Please check your database configuration.</p>' :
                    '<button type="button" onclick="retryDataLoad()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: #dc2626; color: white; border: none; border-radius: 4px; cursor: pointer;">Retry</button>'
                }
                        </div>
                    </td>
                </tr>
            `;

            // Show error in stats
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="error">
                        <h3>Unable to Load Statistics</h3>
                        <p>Database connection failed</p>
                    </div>
                </div>
            `;

            console.error('Technical error details:', technicalMessage);
        }

        /**
         * Show success message temporarily
         */
        function showSuccessMessage(message) {
            const tableBody = document.getElementById('tableBody');

            // Show temporary success message
            tableBody.innerHTML = `
                <tr>
                    <td colspan="7" style="text-align: center; padding: 2rem; color: #16a34a; background: #dcfce7;">
                        <h3>âœ“ ${message}</h3>
                        <p>Table rendering will be implemented in the next task.</p>
                    </td>
                </tr>
            `;

            // Show basic stats
            if (dataManager) {
                const stats = dataManager.getStatistics();
                const statsGrid = document.getElementById('statsGrid');

                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <h3>Total Applications</h3>
                        <div class="value">${stats.totalApplications.toLocaleString()}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Average Salary</h3>
                        <div class="value">$${stats.averageSalary.toLocaleString()}</div>
                    </div>
                    <div class="stat-card">
                        <h3>Certification Rate</h3>
                        <div class="value">${stats.certificationRate}%</div>
                    </div>
                    <div class="stat-card">
                        <h3>Top Employer</h3>
                        <div class="value" style="font-size: 1rem;">${stats.topEmployers[0]?.name || 'N/A'}</div>
                    </div>
                `;
            }
        }

        /**
         * Initialize UI components and event listeners
         */
        function initializeUIComponents() {
            // Initialize table renderer
            tableRenderer = new TableRenderer('dataTable', 'tableBody');

            // Initialize pagination renderer
            paginationRenderer = new PaginationRenderer('pagination');

            // Initialize filter manager
            filterManager = new FilterManager(dataManager);
            filterManager.initializeFilters(dataManager.processedData);

            // Set up event listeners for sorting
            document.addEventListener('tableSort', handleTableSort);

            // Set up event listeners for pagination
            document.addEventListener('pageChange', handlePageChange);
            document.addEventListener('pageSizeChange', handlePageSizeChange);

            // Set up event listeners for filtering
            document.addEventListener('filtersApplied', handleFiltersApplied);

            console.log('UI components initialized');
        }

        /**
         * Handle table sorting events
         */
        function handleTableSort(event) {
            if (!dataManager || !tableRenderer) return;

            const { column, direction } = event.detail;
            console.log(`Sorting by ${column} (${direction})`);

            // Apply sort to data
            dataManager.sortData(column, direction);

            // Update table renderer's sort state to match
            tableRenderer.setSort(column, direction);

            // Re-render the application with sorted data (reset to page 1 after sorting)
            renderApplication(1);
        }

        /**
         * Handle page change events
         */
        function handlePageChange(event) {
            if (!dataManager) return;

            const { page } = event.detail;
            console.log(`Navigating to page ${page}`);

            // Re-render with new page
            renderApplication(page);
        }

        /**
         * Handle page size change events
         */
        function handlePageSizeChange(event) {
            if (!dataManager) return;

            const { pageSize, page } = event.detail;
            console.log(`Changed page size to ${pageSize}, current page: ${page}`);

            // Re-render with new page size
            renderApplication(page, pageSize);
        }

        /**
         * Handle filter applied events
         */
        function handleFiltersApplied(event) {
            if (!dataManager) return;

            const { filterState, filteredData, totalRecords } = event.detail;
            console.log(`Filters applied: ${totalRecords} records match current filters`);

            // Reset to page 1 when filters change
            renderApplication(1);

            // Update filter summary display (optional enhancement)
            updateFilterSummary(filterState);
        }

        /**
         * Update filter summary display (optional enhancement)
         */
        function updateFilterSummary(filterState) {
            if (!filterManager) return;

            const summary = filterManager.getFilterSummary();

            // You could add a filter summary display element to show active filters
            // For now, just log the active filters
            if (summary.hasActiveFilters) {
                console.log('Active filters:', summary.activeFilters.join(', '));
            }
        }

        /**
         * Update data source status indicator
         */
        function updateDataSourceStatus(source, message, isError = false) {
            const statusElement = document.getElementById('dataSourceStatus');
            if (!statusElement) return;

            let iconClass, statusClass, icon;

            if (isError) {
                iconClass = 'error';
                statusClass = 'error';
                icon = 'âš ';
            } else {
                // Always Supabase for this application
                iconClass = 'supabase';
                statusClass = 'supabase';
                icon = 'ðŸ—„';
            }

            statusElement.innerHTML = `
                <div class="data-source-indicator ${statusClass}">
                    <div class="data-source-icon ${iconClass}">${icon}</div>
                    <div>
                        <strong>Data Source:</strong> ${message}
                    </div>
                </div>
            `;
        }

        /**
         * Render the complete application with current data
         */
        function renderApplication(currentPage = 1, pageSize = 50) {
            if (!dataManager || !tableRenderer || !paginationRenderer) {
                console.warn('Application components not initialized');
                return;
            }

            // Get paginated data
            const paginatedData = dataManager.getPaginatedData(currentPage, pageSize);

            // Render statistics
            renderStatistics();

            // Render table
            tableRenderer.renderTable(
                paginatedData.data,
                paginatedData.currentPage,
                paginatedData.totalPages
            );

            // Update pagination
            paginationRenderer.updatePagination(
                paginatedData.currentPage,
                paginatedData.totalPages,
                paginatedData.totalRecords,
                paginatedData.pageSize
            );

            console.log(`Rendered page ${paginatedData.currentPage} of ${paginatedData.totalPages} (${paginatedData.totalRecords} total records)`);
        }

        /**
         * Render statistics cards
         */
        function renderStatistics() {
            if (!dataManager) return;

            const stats = dataManager.getStatistics();
            const statsGrid = document.getElementById('statsGrid');

            if (!statsGrid) return;

            statsGrid.innerHTML = `
                <div class="stat-card">
                    <h3>Total Applications</h3>
                    <div class="value">${stats.totalApplications.toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <h3>Average Salary</h3>
                    <div class="value">$${stats.averageSalary.toLocaleString()}</div>
                </div>
                <div class="stat-card">
                    <h3>Certification Rate</h3>
                    <div class="value">${stats.certificationRate}%</div>
                </div>
                <div class="stat-card">
                    <h3>Top Employer</h3>
                    <div class="value" style="font-size: 1rem;">${stats.topEmployers[0]?.name || 'N/A'}</div>
                </div>
            `;
        }

        /**
         * Retry data loading
         */
        async function retryDataLoad() {
            if (dataLoader) {
                try {
                    await dataLoader.retryFetch();
                } catch (error) {
                    console.error('Retry failed:', error);
                }
            }
        }

        /**
         * Unit Tests for Data Processing
         * These tests can be run from the browser console by calling runDataProcessingTests()
         */
        function runDataProcessingTests() {
            console.log('ðŸ§ª Running H1B Data Processing Unit Tests...\n');

            let totalTests = 0;
            let passedTests = 0;
            let failedTests = 0;

            function runTest(testName, testFunction) {
                totalTests++;
                try {
                    testFunction();
                    console.log(`âœ… ${testName}`);
                    passedTests++;
                } catch (error) {
                    console.error(`âŒ ${testName}: ${error.message}`);
                    failedTests++;
                }
            }

            function expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${expected}, but got ${actual}`);
                        }
                    },
                    toBeNull: () => {
                        if (actual !== null) {
                            throw new Error(`Expected null, but got ${actual}`);
                        }
                    },
                    toBeInstanceOf: (expectedClass) => {
                        if (!(actual instanceof expectedClass)) {
                            throw new Error(`Expected instance of ${expectedClass.name}, but got ${typeof actual}`);
                        }
                    },
                    toHaveLength: (expected) => {
                        if (actual.length !== expected) {
                            throw new Error(`Expected length ${expected}, but got ${actual.length}`);
                        }
                    },
                    toContain: (expected) => {
                        if (!actual.includes(expected)) {
                            throw new Error(`Expected ${actual} to contain ${expected}`);
                        }
                    }
                };
            }

            console.log('ðŸ“… Testing Date Parsing Functionality...');

            runTest('Parse valid ISO date strings', () => {
                const dataManager = new DataManager();
                const result = dataManager.parseDate('2023-01-15');
                expect(result).toBeInstanceOf(Date);
                expect(result.getFullYear()).toBe(2023);
                expect(result.getMonth()).toBe(0); // January is 0
                // Use getUTCDate() to avoid timezone issues
                expect(result.getUTCDate()).toBe(15);
            });

            runTest('Parse MM/DD/YYYY format dates', () => {
                const dataManager = new DataManager();
                const result = dataManager.parseDate('01/15/2023');
                expect(result).toBeInstanceOf(Date);
                expect(result.getFullYear()).toBe(2023);
            });

            runTest('Return null for empty date strings', () => {
                const dataManager = new DataManager();
                expect(dataManager.parseDate('')).toBeNull();
                expect(dataManager.parseDate(null)).toBeNull();
                expect(dataManager.parseDate(undefined)).toBeNull();
                expect(dataManager.parseDate('N/A')).toBeNull();
            });

            runTest('Return null for invalid date strings', () => {
                const dataManager = new DataManager();
                expect(dataManager.parseDate('invalid-date')).toBeNull();
                expect(dataManager.parseDate('not-a-date')).toBeNull();
            });

            console.log('\nðŸ’° Testing Salary Normalization Functionality...');

            runTest('Normalize hourly wages to annual salary', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('50', 'Hour');
                expect(result).toBe(104000); // 50 * 2080 hours
            });

            runTest('Normalize monthly wages to annual salary', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('5000', 'Month');
                expect(result).toBe(60000); // 5000 * 12 months
            });

            runTest('Normalize weekly wages to annual salary', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('1000', 'Week');
                expect(result).toBe(52000); // 1000 * 52 weeks
            });

            runTest('Keep annual wages unchanged', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('75000', 'Year');
                expect(result).toBe(75000);
            });

            runTest('Handle bi-weekly wages', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('2000', 'Bi-Weekly');
                expect(result).toBe(52000); // 2000 * 26 bi-weekly periods
            });

            runTest('Return 0 for invalid wage amounts', () => {
                const dataManager = new DataManager();
                expect(dataManager.normalizeSalary('', 'Hour')).toBe(0);
                expect(dataManager.normalizeSalary(null, 'Hour')).toBe(0);
                expect(dataManager.normalizeSalary('invalid', 'Hour')).toBe(0);
                expect(dataManager.normalizeSalary(undefined, 'Hour')).toBe(0);
            });

            runTest('Handle case-insensitive wage units', () => {
                const dataManager = new DataManager();
                expect(dataManager.normalizeSalary('50', 'HOUR')).toBe(104000);
                expect(dataManager.normalizeSalary('50', 'hour')).toBe(104000);
                expect(dataManager.normalizeSalary('50', 'Hour')).toBe(104000);
                expect(dataManager.normalizeSalary('50', 'hourly')).toBe(104000);
            });

            runTest('Default to annual for unknown wage units', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('75000', 'unknown-unit');
                expect(result).toBe(75000);
            });

            runTest('Handle decimal wage amounts', () => {
                const dataManager = new DataManager();
                const result = dataManager.normalizeSalary('25.50', 'Hour');
                expect(result).toBe(53040); // 25.50 * 2080, rounded
            });

            console.log('\nðŸš¨ Testing Error Handling for Malformed Data...');

            runTest('Validate required fields and return errors', () => {
                const dataManager = new DataManager();
                const malformedRecord = {};
                const errors = dataManager.validateRecord(malformedRecord);
                expect(errors).toContain('Missing case number');
                expect(errors).toContain('Missing employer name');
                expect(errors).toContain('Missing job title');
                expect(errors).toContain('Missing case status');
            });

            runTest('Return no errors for valid record', () => {
                const dataManager = new DataManager();
                const validRecord = {
                    CASE_NUMBER: 'I-200-12345-123456',
                    EMPLOYER_NAME: 'Test Company',
                    JOB_TITLE: 'Software Engineer',
                    CASE_STATUS: 'Certified'
                };
                const errors = dataManager.validateRecord(validRecord);
                expect(errors).toHaveLength(0);
            });

            runTest('Handle partial validation errors', () => {
                const dataManager = new DataManager();
                const partialRecord = {
                    CASE_NUMBER: 'I-200-12345-123456',
                    EMPLOYER_NAME: 'Test Company'
                };
                const errors = dataManager.validateRecord(partialRecord);
                expect(errors).toHaveLength(2);
                expect(errors).toContain('Missing job title');
                expect(errors).toContain('Missing case status');
            });

            runTest('Process data with mixed valid and invalid records', () => {
                const mixedData = [
                    {
                        CASE_NUMBER: 'I-200-12345-123456',
                        EMPLOYER_NAME: 'Valid Company',
                        JOB_TITLE: 'Software Engineer',
                        CASE_STATUS: 'Certified',
                        WAGE_RATE_OF_PAY_FROM: '75000',
                        WAGE_UNIT_OF_PAY: 'Year',
                        RECEIVED_DATE: '2023-01-15',
                        DECISION_DATE: '2023-03-20'
                    },
                    {
                        CASE_NUMBER: 'I-200-12345-123457',
                        EMPLOYER_NAME: 'Another Company',
                        JOB_TITLE: 'Data Scientist',
                        CASE_STATUS: 'Denied',
                        WAGE_RATE_OF_PAY_FROM: 'invalid-salary',
                        WAGE_UNIT_OF_PAY: 'Hour',
                        RECEIVED_DATE: 'invalid-date',
                        DECISION_DATE: '2023-04-15'
                    }
                ];

                const dataManager = new DataManager(mixedData);
                expect(dataManager.processedData).toHaveLength(2);

                // First record should have valid processed data
                expect(dataManager.processedData[0].ANNUAL_SALARY).toBe(75000);
                expect(dataManager.processedData[0].RECEIVED_DATE_PARSED).toBeInstanceOf(Date);

                // Second record should handle invalid data gracefully
                expect(dataManager.processedData[1].ANNUAL_SALARY).toBe(0);
                expect(dataManager.processedData[1].RECEIVED_DATE_PARSED).toBeNull();
            });

            runTest('Handle empty or null input data', () => {
                const dataManager1 = new DataManager([]);
                expect(dataManager1.processedData).toHaveLength(0);

                const dataManager2 = new DataManager();
                expect(dataManager2.rawData).toHaveLength(0);
            });

            runTest('Handle records with null or undefined field values', () => {
                const recordWithNulls = {
                    CASE_NUMBER: 'I-200-12345-123456',
                    EMPLOYER_NAME: 'Test Company',
                    JOB_TITLE: 'Software Engineer',
                    CASE_STATUS: 'Certified',
                    WAGE_RATE_OF_PAY_FROM: null,
                    WAGE_UNIT_OF_PAY: undefined,
                    RECEIVED_DATE: null,
                    DECISION_DATE: undefined
                };

                const dataManager = new DataManager([recordWithNulls]);
                expect(dataManager.processedData).toHaveLength(1);

                const processed = dataManager.processedData[0];
                expect(processed.ANNUAL_SALARY).toBe(0);
                expect(processed.RECEIVED_DATE_PARSED).toBeNull();
                expect(processed.DECISION_DATE_PARSED).toBeNull();
            });

            console.log('\nðŸ”„ Testing Sorting Functionality...');

            runTest('Sort by employer name (ascending)', () => {
                const testData = [
                    { EMPLOYER_NAME: 'Zebra Corp', CASE_STATUS: 'Certified' },
                    { EMPLOYER_NAME: 'Apple Inc', CASE_STATUS: 'Denied' },
                    { EMPLOYER_NAME: 'Microsoft', CASE_STATUS: 'Certified' }
                ];

                const dataManager = new DataManager(testData);
                const sorted = dataManager.sortData('EMPLOYER_NAME', 'asc');

                expect(sorted[0].EMPLOYER_NAME).toBe('Apple Inc');
                expect(sorted[1].EMPLOYER_NAME).toBe('Microsoft');
                expect(sorted[2].EMPLOYER_NAME).toBe('Zebra Corp');
            });

            runTest('Sort by employer name (descending)', () => {
                const testData = [
                    { EMPLOYER_NAME: 'Apple Inc', CASE_STATUS: 'Certified' },
                    { EMPLOYER_NAME: 'Zebra Corp', CASE_STATUS: 'Denied' },
                    { EMPLOYER_NAME: 'Microsoft', CASE_STATUS: 'Certified' }
                ];

                const dataManager = new DataManager(testData);
                const sorted = dataManager.sortData('EMPLOYER_NAME', 'desc');

                expect(sorted[0].EMPLOYER_NAME).toBe('Zebra Corp');
                expect(sorted[1].EMPLOYER_NAME).toBe('Microsoft');
                expect(sorted[2].EMPLOYER_NAME).toBe('Apple Inc');
            });

            runTest('Sort by salary (numeric ascending)', () => {
                const testData = [
                    { WAGE_RATE_OF_PAY_FROM: '100000', WAGE_UNIT_OF_PAY: 'Year', EMPLOYER_NAME: 'High Pay' },
                    { WAGE_RATE_OF_PAY_FROM: '50000', WAGE_UNIT_OF_PAY: 'Year', EMPLOYER_NAME: 'Low Pay' },
                    { WAGE_RATE_OF_PAY_FROM: '75000', WAGE_UNIT_OF_PAY: 'Year', EMPLOYER_NAME: 'Mid Pay' }
                ];

                const dataManager = new DataManager(testData);
                const sorted = dataManager.sortData('WAGE_RATE_OF_PAY_FROM', 'asc');

                expect(sorted[0].ANNUAL_SALARY).toBe(50000);
                expect(sorted[1].ANNUAL_SALARY).toBe(75000);
                expect(sorted[2].ANNUAL_SALARY).toBe(100000);
            });

            runTest('Sort by salary (numeric descending)', () => {
                const testData = [
                    { WAGE_RATE_OF_PAY_FROM: '50000', WAGE_UNIT_OF_PAY: 'Year', EMPLOYER_NAME: 'Low Pay' },
                    { WAGE_RATE_OF_PAY_FROM: '100000', WAGE_UNIT_OF_PAY: 'Year', EMPLOYER_NAME: 'High Pay' },
                    { WAGE_RATE_OF_PAY_FROM: '75000', WAGE_UNIT_OF_PAY: 'Year', EMPLOYER_NAME: 'Mid Pay' }
                ];

                const dataManager = new DataManager(testData);
                const sorted = dataManager.sortData('WAGE_RATE_OF_PAY_FROM', 'desc');

                expect(sorted[0].ANNUAL_SALARY).toBe(100000);
                expect(sorted[1].ANNUAL_SALARY).toBe(75000);
                expect(sorted[2].ANNUAL_SALARY).toBe(50000);
            });

            runTest('Sort by date (chronological)', () => {
                const testData = [
                    { DECISION_DATE: '2023-03-15', EMPLOYER_NAME: 'Latest' },
                    { DECISION_DATE: '2023-01-10', EMPLOYER_NAME: 'Earliest' },
                    { DECISION_DATE: '2023-02-20', EMPLOYER_NAME: 'Middle' }
                ];

                const dataManager = new DataManager(testData);
                const sorted = dataManager.sortData('DECISION_DATE', 'asc');

                expect(sorted[0].EMPLOYER_NAME).toBe('Earliest');
                expect(sorted[1].EMPLOYER_NAME).toBe('Middle');
                expect(sorted[2].EMPLOYER_NAME).toBe('Latest');
            });

            runTest('Handle null values in sorting (sort to end)', () => {
                const testData = [
                    { EMPLOYER_NAME: 'Valid Company', DECISION_DATE: '2023-01-15' },
                    { EMPLOYER_NAME: null, DECISION_DATE: '2023-02-20' },
                    { EMPLOYER_NAME: 'Another Company', DECISION_DATE: null }
                ];

                const dataManager = new DataManager(testData);
                const sorted = dataManager.sortData('EMPLOYER_NAME', 'asc');

                // Null values should be sorted to the end
                expect(sorted[0].EMPLOYER_NAME).toBe('Another Company');
                expect(sorted[1].EMPLOYER_NAME).toBe('Valid Company');
                expect(sorted[2].EMPLOYER_NAME).toBe(null);
            });

            runTest('Sort direction toggle functionality', () => {
                const testData = [
                    { EMPLOYER_NAME: 'B Company' },
                    { EMPLOYER_NAME: 'A Company' },
                    { EMPLOYER_NAME: 'C Company' }
                ];

                const dataManager = new DataManager(testData);

                // First sort ascending
                let sorted = dataManager.sortData('EMPLOYER_NAME', 'asc');
                expect(sorted[0].EMPLOYER_NAME).toBe('A Company');
                expect(dataManager.getCurrentSort().direction).toBe('asc');

                // Then sort descending
                sorted = dataManager.sortData('EMPLOYER_NAME', 'desc');
                expect(sorted[0].EMPLOYER_NAME).toBe('C Company');
                expect(dataManager.getCurrentSort().direction).toBe('desc');
            });

            console.log('\nðŸ”„ Testing Data Processing Integration...');

            runTest('Process complete H1B record correctly', () => {
                const sampleRecord = {
                    CASE_NUMBER: 'I-200-12345-123456',
                    EMPLOYER_NAME: 'Tech Corp',
                    JOB_TITLE: 'Senior Software Engineer',
                    CASE_STATUS: 'Certified',
                    WAGE_RATE_OF_PAY_FROM: '65',
                    WAGE_UNIT_OF_PAY: 'Hour',
                    RECEIVED_DATE: '2023-01-15',
                    DECISION_DATE: '2023-03-20',
                    WORKSITE_CITY: 'San Francisco',
                    WORKSITE_STATE: 'CA'
                };

                const dataManager = new DataManager([sampleRecord]);
                expect(dataManager.processedData).toHaveLength(1);

                const processed = dataManager.processedData[0];
                expect(processed.ANNUAL_SALARY).toBe(135200); // 65 * 2080
                expect(processed.RECEIVED_DATE_PARSED).toBeInstanceOf(Date);
                expect(processed.DECISION_DATE_PARSED).toBeInstanceOf(Date);
            });

            // Print test summary
            console.log(`\nðŸ“Š Test Results Summary:`);
            console.log(`Total Tests: ${totalTests}`);
            console.log(`âœ… Passed: ${passedTests}`);
            console.log(`âŒ Failed: ${failedTests}`);
            console.log(`Success Rate: ${Math.round((passedTests / totalTests) * 100)}%`);

            if (failedTests === 0) {
                console.log('\nðŸŽ‰ All tests passed! Data processing functionality is working correctly.');
            } else {
                console.log(`\nâš ï¸  ${failedTests} test(s) failed. Please review the implementation.`);
            }

            return {
                total: totalTests,
                passed: passedTests,
                failed: failedTests,
                successRate: Math.round((passedTests / totalTests) * 100)
            };
        }

        // Make test function available globally for console access
        window.runDataProcessingTests = runDataProcessingTests;

        // Start the application when DOM is loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>

</html>